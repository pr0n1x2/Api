# BASE APP(ru)

## Формат роутов

## Формат ответов
Все ответы сервера или фронта(в случае WS) используют стандартизированый формат

ответы
| ключ                                                    | варианты                |
| ------------------------------------------------------- | ----------------------- |--
| "status"                                                |                         | Обязательное поле, обозначает успешность действия которое запустил запрос.
|                                                         | "ok"                    | все хорошо
|                                                         | "error"                 | ошибка (общая)
|                                                         | "invalid data"          | ошибка валидации (входящие данные в неправльном формате, уточнение ошибки в "payload")
|                                                         | "invalid token"         | ошибка доступа (что нетак с jwt или правами доступа)
| ------------------------------------------------------- | ----------------------- |--
| "error"                                                 | текст                   | код ошибки, текстом, расширенная информация об ошибке приходит в payload
| ------------------------------------------------------- | ----------------------- |--
| "payload"                                               | любой объект            | непосредствено полезная нагрузка отдаваемая в запросе
| ------------------------------------------------------- | ----------------------- |--

Пример 1
{ "status": "ok" } - это обязательный ответ на любой запрос, даже если он не должен отдать что-то в ответ
{ "status": "ok", "payload": { "id": 123456789 } } - ответ "все хорошо" + передача дополнительной информации. Такой ответ может быть к примеру на запрос создания пользователя


этот же формат рекомендуем для типовых ответов функций в контроллерах

Плохо
....
try {
  const data = await decode(token);
  ....
} catch (err) {
  ....
}
в данном случае неуспешность действия и критические ошибки в коде сделаные программистом пойдут в одну кучу

хорошо
....
const data = await decode(token);
const { status, payload } = data;
if( status !== 'ok' ) {
    ....
}
в данном случае мы отслеживаем конкретно ситуацию неуспешного выполнения функции, предусмотренное как штатную ситуацию. Не забывайте, что { status: 'ok' } это только формат ретурна для функций,  если вам нужен try .... catch, используйте try .... catch!

для функций возвращающий однозначный ответ допустимо использовать простые форматы ответов
const sum = (a, b) => {
  const result = a + b;
  return result;
}

Не ложите данные напрямую в payload, создавайте ключи. К примеру, у вас есть запрос "/courses" по которому фронт запрашивает список курсов на учебном портале
Плохо
{ 
  "status": "ok", 
  "payload": [
    { "id": 123456789, name: "course 1" }, { "id": 123456789, name: "course 1" }
  ]
}
Тут в "payload" сразу лежит массив с курсами, что плохо, так как если в будущем вам нужно будет добавить какие либо дополнительные данные, прийдеться менять существующие поля в "payload"
Хорошо
{ 
  "status": "ok", 
  "payload": {
    "courses": [{ "id": 123456789, name: "course 1" }, { "id": 123456789, name: "course 1" }]
  }
}
Это хорошо, так как вы можете свободно добавлять новые ключи в "payload", не меняя уже существующие

## подробнее ошибки 
Этот раздел касаеться всех статусов относяшихся к ошибкам, на момент написания документации, любой статус кроме "ok" это ошибки.
Уточняющая информация об ошибке передаеться в ключе payload.error или payload.errors если масив ошибок(например при валидации), формат внутри payload.error при этом согласовываеться отдельно и может быть по сути любым, в зависимости от того, как генерировалась ошибка.

Пример 1
{
  status: "invalid data",
  payload: {
    errors: [{
      keyword: "maxItems",
      dataPath: ".lines[3].coordinates",
      schemaPath: "#/properties/lines/items/properties/coordinates/maxItems",
      params: {
        limit: 2
      },
      message: "should NOT have more than 2 items"
    }]
  },
}
В данном случае это формат ошибки валидации json схемы, генерируемый ajv.

Пример 2
{
  status: "invalid token",
  payload: {
    errors: [{
      keyword: "maxItems",
      dataPath: ".lines[3].coordinates",
      schemaPath: "#/properties/lines/items/properties/coordinates/maxItems",
      params: {
        limit: 2
      },
      message: "should NOT have more than 2 items"
    }]
  },
}
снова ajv.

статусы ошибок:
{ "status": "error", "payload": { .... } } - общая ошибка, тоесть любые нетиповые ошибки отдают этот статус.
{ "status": "invalid data", "payload": { .... } } - ошибки валидации json схемы(неверный формат передаваемых данных). Обычно мы используем ajv для валидации json схем
{ "status": "invalid token", "payload": { .... } } - сюда относяться все ошибки связанные с JWT, например неправильно сгенерированный ключь
{ "status": "invalid access" } - сюда относяться все ошибки связанные с правами доступа, например попытка войти забаненым профилем.

Обратите внимание, что с целью безопасности, в режимах продакшена, приложения должны выдавать следующие значения 
- просто http код 500, без объяснений - на непредвиденные ошибки
- { "status": "error" }, без разьяснений в payload - разьяснения передают в логи модулем logger, пользователь не должен видеть подробной инфы, на все предусмотренные ошибки
- { "status": "invalid token" }, без разьяснений в payload - токены выдает наш сервер аутификации, не нужна обычному пользователю инфа почему его токен неправильный
- вместо { "status": "invalid access" } отдают типовую ошибку 404 - не нужна обычному пользователю информация что по этому url вобще существует закрытый ресурс. Исключение - если проектом предусмотрен шаринг нашего апи и документация по нему есть в открытом доступе. Для случаев когда с апи работает постороння команда - возможно открытие ошибок, но по возможности эта функция привязываеться к конкретным айпи или токенам. 

текущий режим можно проверить
const env = process.env.NODE_ENV;
if (env !== 'development') { .... }

## Структура проекта

| Файл или папка                 | Что это?
| ------------------------------ | ------------------
| [bin](#bin)                    | скрипты запуска (точки входа и ранеры)
| [config](#config)              | конфиги
| [log](#log)                    | логи
| [logger](#logger)              | логгер для логов
| [models](#models)              | модели бд
| [httpRoutes](#httpRoutes)      | роуты http сервера. (В зависимости от проекта, могут присутсвовать и другие, например WS сервера)
| [schemas](#schemas)            | json схемы для валидации
| [storage](#storage)            | точки доступа к хранилищам (доступ к бд, хранилище сессий и другие)
| [tmp](#tmp)                    | временные файлы (складывайте их сюда чтобы не засорять проект)
| [utils](#utils)                | маленькие скрипты-хелперы, ради которых нет смысла подключать отдельные либы. (Наример функция randInt генерирующая рандомный инт или другие.)

## <a name="bin"></a> bin: скрипты запуска

В этой папке обычно расположены файл www и папка runners.
Файл www это обычно тот файл который запускаеться командой start из package.json.
Файл www обычно без расширения, вместо него используеться специальна строка в файле, "#!/usr/bin/env node", это так называемый shebang. В Unix подобных системах расширение слабо связано с тем какой программой должен быть запущен скрипт, вместо него используют shebang. Возможности shebang не ограничены только этим, но в нашем случае используються именно для этого. Так как большинство серверов работают на Unix подобных системах, shebang решение избавляющее от многих проблем. MacOS - Unix подобная система и тоже использует shebang. Windows игнорирует shebang, но реагирует на команду node прописанную в package.json, с ним никаких проблем.

Кроме www, в этой папке могут быть и другие файлы без расширения, что это за файлы?
имя www подразумевает что вы запускаете веб приложение, но могут быть и другие варианты. Давайте возьмем для примера современный автомобиль, обычный режим запуска автомобиля это езда, но помимо этого у него могут быть  режимы: "в сервисе" - где автомобиль не едет, но разлокируеться часть функций, "паркинг" - где блокируютсья колеса, "авария" - где стреляют подушки и происходить еще бог знает что. Автомобиль один, а режимы использования могут быть разные, точно также и приложения, обычный режим запуска - "веб приложение", сокращенно www, это режим когда приложение просто запускаеться и едит, а помимо этого, могут быть и другие режимы.

Давайте представим что для нормальной нормальной работы вашего веб приложения вам нужно:

* подключиться к базе данных
* поднять http и ws сервер

За каждый этап отвечает маленький микро скрипт - раннер, они соответственно лежат в папке runners, это сделано для того, чтобы избежать дублирования кода, ведь эти же шаги скорее всего будут использовать и другие режимы запуска, также вам будет проще включать или исключать ранеры конктретно для текущего проекта чем переписывать один большой скрипт запуска.

Расмотрим на примере первого шага, у вас есть база данных и вам нужно к ней подключиться. Вы не можете использовать бд пока не подключитесь к ней. То есть у кода компонента условно есть две части:

* Часть которая отвечает за подключение к бд, запускаеться 1 раз и больше никогда не используеться. Эта часть соответствует обычно критериям:
  * запускает процесы внутри вашего компонента, но никак дальше не участвует
  * не относиться к настройкам компонента, которые вы скорее всего будете менять если захотите повтороно использовать код в другом проекте
  * не являеться точкой доступа к функциям компонента
  Не всегда возможно отделить процесы запуска от процеса работы, нет ничего страшного в том если вся эта часть останеться в файле компонента, но следует создать функцию init или что-то аналогичное, и дергать эту функцию из ранера.
* Часть которая используеться в процесе работы, этого недолжно быть в раннере, это находиться в отдельном модуле никак с ранером не связаном.

У вас выйдет, файл www, раннер dbRunner и компонент db.
Файл www дергает нужные ранеры, он огранизовывает последовательность ранеров, если один ранер должен запускаться только после другого, может переддавать какие-то данные между раннерами если это нужно, но никогда не содержит сам код ранера.

`Скорее всего вам будет тяжело сразу понять где ранер, а где компонент, это не так важно, не думайте об этом много, главное само наличие ранера.`

Блокирующие операции.
Вы должны понимать что скрипты запуска приложения это не тоже самое что само приложение, то что происходит при запуске кардинально отличаеться от того как это используют в работе, потому и правила тут другие. При запуске допустимы, а где-то и вовсе необходимы, блокирующие операции.

## <a name="config"></a> config: конфиги

Любые общие конфиги, в том числе конфиги генерирующиеся на основе какогото алгоритма но дающие на выходе простые объекты, должны быть тут.
Внутри этого модуля конфигов спрятана библиотека nconf. На сегодня мы используем только две функции nconf - имутабельность и мердж конфигов из файлов, можно сделать это другими методами, но нет смысла менять то что и так прекрасно работает.

Любой .js файл в этом каталоге, кроме index.js, становиться конфигом. Если вы создаете файл app.js, то файл должен отдавть нарружу объект в формате { app: {<ваши конфиги>} }. То есть имя ключа соответствует имени файла.

Почему мы не автоматизировали "имя ключа = имени файла"? нам встречались случаи когда один конфиг должен был отдать несколько ключей. Мы оставили возможность отдать несколько ключей, как самое простое в реализации решение, тоесть вы можете в файле app.js отдать не только { app: {<ваши конфиги>} }, но и { app: {<ваши конфиги>}, app2: {<ваши конфиги2>} }, ключ app2 тоже будет добавлен в конфиг, но вам нестоит этого делать без необходимости, наше соглашение гласит что имя ключа должно соответствовать имени файла.

Как этим пользоваться?
К примеру у вас в папке config есть файлы server.js и db.js. Это значит что у вас есть два объекта которые отдает каждый из этих файлов:
server: {
  port: 8080
}

и

db: {
  uri: 'mongodb://localhost:27017/myapp'
}

Внутренний алгоритм конфигов соеденит эти два массива в один:
{
  server: {
    port: 8080
  },
  db: {
    uri: 'mongodb://localhost:27017/myapp'
  }
}

это и будет конфиг вашего приложения, чтобы получить к нему доступ используеться синтаксис nconf.
К примеру вам нужен порт из настроек сервера, его можно получить так:
const port = require('config').get('server:port');

о консольных аргументах и переменных окружения(NODE_ENV и другие).
Ранее мы также делали их частью конфига, то-есть к примеру переменную NODE_ENV мы получали как часть конфигурации
const port = require('config').get('NODE_ENV'), но мы перестали так делать, так как это создавало некоторые проблемы и не давало особой выгоды. Потому мы приняли некоторые соглашения:

* NODE_ENV используються как есть, то-есть их получают напрямую из process.env
* Не стандартные переменные окружения, то-есть те что вы придумали сами, включая и те что имеют типовые названия, должны быть получены из process.env внутри модуля config и помещены в какойто раздел, в дальнейшем с их полученают с этого раздела.

Например порт для http сервера передаеться переменную PORT в строке запуска, следовательно, в конфиге server.js вы получаете порт в какуюто переменную:

const port = process.env.PORT;

Порт должен быть Int, но к вам прийдет string, так как из консоли вам всегда приходит string, вам надо перевести его numeric и удостовериться что это валидный порт:

const port = normalizePort(process.env.PORT);

Вам также следует указать порт по умолчанию
const port = normalizePort(process.env.PORT) || 3000;;

После выпомещаете полученные данные к конфиг:

const port = normalizePort(process.env.PORT) || 3000;

module.exports = {
  server: {
    port,
  },
};

В дальнейшем, когда http сервер получит порт из конфигов, напомню
const port = require('config').get('server:port');
У сервер нет необходимости думать о том, откуда взялся этот порт и коректен ли он, он просто его использует.

Использование других компонентов внутри конфигов?
Этого не стоит делать, у модуля config уникальная ситуация, он нужен для работы практически любого другого модуля.
К примеру, вы хотите написать что-то в лог используя logger, вы не сможете этого сделать. Для своей работы, logger должен получить свои конфиги из модуля config, а config до того как отдать ему эти данные, должен инициализироваться, если в этот момент вы обратитесь к logger, получите ошибку о том что logger еще не подключен.

Если у модуля нет зависимостей от config, я могу использовать его в процесе иницыализации?
Только если вы понимаете что делаете, если вы сделаете так, скорее всего вы больше не сможете использовать config для хранения конфигураций этого модуля, если в будущем они у него появяться.

Асинхронные операции внутри конфилов?
Вы должны понимать что конфиг это первое что иницыализируеться при старте приложения, он не должен пропускать любой другой код впереди себя. Мы могли бы добавить сюда возможность использовать промисы, но это в значительной мере усложнит код и пока в этом небыло необходимости. Возможно в будущем. Не используйте асинхронные операции, благо почти любому асинхронному действию, есть синхронный аналог, а блокирующие операции в конфигах допустимы, как части иницыализации всего приложения.

## <a name="log_logger"></a> log и logger: логи и логгер для логов

## <a name="models"></a> models: модели бд

## <a name="routes"></a> httpRoutes и wsRoutes: роуты http сервера и роуты ws сервера

## <a name="schemas"></a> schemas: точки доступа к хранилищам

## <a name="storage"></a> storage: точки доступа к хранилищам

## <a name="tmp"></a> tmp: временные файлы

## <a name="utils"></a> utils: скрипты-хелперы
